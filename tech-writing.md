# 🤔동시성에 의한 이슈를 스레드 관점에서 파헤쳐보기

## 주제

동시에 요청을 보내는 것으로 인해 생기는 문제의 원인을 스레드 관점에서 알아본다.

## 대상 독자

스레드의 개념에 대한 배경 지식이 없는 독자
스레드와 동시성 이슈의 관계성에 대해 이해하고자 하는 독자
JVM에 대해 이해하고 있는 독자


## 목차

- 프로젝트에서 생긴 문제에 대해 알아보기

- 여러 요청이 서버에 도착하면 생기는 일
    - 스레드란?
    - 스레드가 필요한 이유
    - 병렬성
    - JVM에서 스레드가 생성되는 방식

- 문제 원인 분석하기

- 해결 방법

- 프로젝트에 적용한 방식

- 마무리하며

---


# 프로젝트에서 생긴 문제에 대해 알아보기

집단 내에서 같이 생활하는 사람들과 유대감을 쌓기 위한 모임 서비스. 모우다 에서는 쉽고 간편하게 모임을 만들 수 있도록 여러 가지 기능을 제공합니다.
모우다에서 학과나 회사, 혹은 우아한테크코스처럼 소속 집단 단위를 뜻하는 용어를 다락방이라고 칭하고 있어요.

모우다 서비스에서 중요한 서비스 기능 중 하나는 다락방에 참여하는 것과 모임에 참여하는 것이 있습니다. 사용자는 아래와 같이 다락방 참여나 모임 참여와 같은 버튼을 눌러 요청을 보내게 되죠.

`참여`라는 요구사항에는 아래 내용이 포함되어있습니다.

> 하나의 모임이나 다락방에는 한 명의 회원만 참여할 수 있다.

이를 서비스 레이어의 비즈니스 로직으로 구현하였어요.

```java
	private void validateAlreadyParticipated(Moim moim, DarakbangMember darakbangMember) {
		boolean isChamyoExists = chamyoRepository.existsByMoimIdAndDarakbangMemberId(
			moim.getId(), darakbangMember.getId()
		);
		if (isChamyoExists) {
			throw new ChamyoException(HttpStatus.BAD_REQUEST, ChamyoErrorMessage.ALREADY_PARTICIPATED);
		}
	}
```

하지만 웹 서비스가 배포되고 QA를 하던 중, 아래와 같은 오류 상황을 마주했습니다.

![image](https://github.com/user-attachments/assets/b5b58a2f-8544-40af-a218-e1a43af2bb16)

먼저, 같은 회원이 같은 모임에 두 번 이상 참여가 가능하다는 버그가 있었습니다.  또한, 최대 인원이 2명임에도 이를 초과하여 참여가 가능한 문제가 있었어요.

같은 회원이 여러 번 참여하는 상황을 방지하기 위한 비즈니스 로직이 있었음에도 이러한 문제가 생긴 이유는 무엇일까요?

그림을 통해 알아봅시다. 우선 비즈니스 로직이 제대로 반영되는 정상적인 흐름은 다음과 같아요.

![image](https://github.com/user-attachments/assets/28acc3e2-23cb-41ad-870f-8a87be1648c7)

```
1. 처음 요청을 보내서 참여를 시도한다.
2. 현재 참여 인원과 최대 참여 인원을 비교한다. 이때 회원이 참여 중인지 확인한다. (SELECT)
3. 최대 참여 인원을 넘지 않는다면 모임에 참여한다. (INSERT)
4. 두 번째 요청이 참여를 시도한다. 
5. 이미 참여한 회원이므로 모임 참여에 실패한다.
```

하지만 여러 요청이 동시에 생기면 어떻게 될까요? 아래 상황을 가정해봤습니다.

![image](https://github.com/user-attachments/assets/6d0bc432-6e99-4a31-ac61-c114eaeb9e19)


앞 요청이 실제로 데이터베이스에 반영되기 전에 검증 로직을 수행하니, 두 개의 요청 모두 INSERT 를 진행할 거에요.


> 하나의 모임이나 다락방에는 한 명의 회원만 참여할 수 있다.

요구사항이 언제나 잘 지켜지기 위해서 해결해야 할 문제는 무엇일까요?
뒤늦은 요청의 검증 로직이 항상 앞선 요청의 작업이 끝난 다음 수행됨을 보장하는 것입니다.

우선 이 현상이 왜 가능한 지에 대해 알아봅시다.


# 여러 요청이 서버에 도착하면 생기는 일

하나의 애플리케이션을 띄우고 있지만, 위의 예시처럼 두 개 이상의 요청이 동시에 애플리케이션에 접근하는 상황이 가능합니다.

이 이유는 하나의 프로세스(자바 애플리케이션)는 여러 개의 스레드 (여러 개의 요청)가 생성될 수 있기 때문이에요.

스레드에 대해서 조금 더 자세히 설명해보겠습니다.





## 스레드란?

스레드 (Thread)는 프로세스의 자원을 이용해서 실제로 작업을 수행하는 역할을 합니다.

자바 애플리케이션 내에서도 요청마다 서로 다른 스레드가 할당됩니다. 따라서 하나의 요청을 처리하기 위해 한 스레드에서 작업을 수행하고 있더라도, 다른 스레드에서 다른 요청을 동시에 처리할 수 있습니다.

동시에 요청을 보냈을 때 다른 작업이 끝나기도 전에 다음 작업을 시작할 수 있는 이유가 여기에 있습니다.

그럼 자바 애플리케이션 내에서 스레드를 하나만 사용하도록 강제하면 문제가 해결되지 않을까요?

네 맞습니다. 😀

프로세스 내에 스레드의 개수가 한 개라면 싱글 스레드, 여러 개라면 멀티 스레드라고 해요. 자바 애플리케이션은 기본적으로 멀티 스레드 환경을 지원하고 있어요.

왜 여러 요청에 의해 문제가 생길 수 있음에도 자바는 멀티 스레드 환경을 택했을까요? 멀티 스레드 환경은 어떤 이점을 가지고 있을까요?

### 스레드가 필요한 이유

우선 스레드가 필요한 이유에 대해서 알아봅시다. 스레드는 프로세스의 작업을 나누어 처리합니다. 즉 스레드는 프로세스가 수행하는 작업의 단위라고 할 수 있어요. 스레드가 있기 때문에 클라이언트로부터 서블릿이 요청을 받아 응답을 내보낼 수 있습니다.

사용자가 아주 많은 서비스에서 정상적으로 서버가 수많은 요청와 응답을 처리할 수 있는 이유도 멀티 스레드 환경이기 때문입니다.

싱글 스레드 환경이라면 한 번에 한 명의 사용자만 받을 수 있었을 거에요. 멀티 스레드 환경에서는 여러 스레드가 여러 작업을 번갈아가며 마치 동시에 처리하는 것처럼 보이게 합니다. 이를 동시성 (Concurrency)라고 해요.

스레드가 여러 작업을 번갈아가며 처리하도록 하여 동시성을 구현한다

라고 하였는데, 그럼 여러 프로세스가 작업을 번갈아가며 동시성을 처리할 수 있지 않을까요? 왜 스레드라는 개념이 꼭 필요한 걸까요?


프로세스가 작업을 수행하려면 CPU와 메모리에 자신의 상태 정보를 저장해야 합니다. 멀티 프로세스 환경에서 동시성을 구현하려면 프로세스의 정보를 저장하고 복구하는 과정이 빠르게 반복되어야해요.

하지만 프로세스와 다르게 스레드는 프로세스의 일부 메모리를 공유하고 있어요. 그래서 프로세스가 한 번 메모리에 적재되면 불필요한 오버헤드 없이 스레드가 번갈아가며 작업을 처리할 수 있을 것입니다.

![image](https://github.com/user-attachments/assets/ff1f42ae-9975-482c-9c4b-f2c6f7659075)


JVM (Java Virtual Machine) 상에서 메모리 구조를 도식화하였습니다.

여러 스레드가 Method 영역과 Heap 영역을 공유하고 있는 것을 볼 수 있어요. Method 영역에는 클래스 정보과 메서드, 상수 등이 공유되며 Heap 영역에서는 객체나 전역 변수 등이 공유됩니다.
동시성을 지원하기 위해서 여러 번 이러한 정보들이 다시 로딩될 필요 없이, 한 번 생성되기만 하면 많은 스레드에서 효율적으로 처리할 수 있습니다.

실제로 일반적으로 JVM (Java Virtual Machine)을 실행하면 32~64MB의 물리 메모리가 점유되는데요. 이와 반대로 스레드는 1MB 이내의 메모리를 점유한다고 합니다. 메모리 사용 관점에서도 멀티 프로세스 환경보다는 멀티 스레드 환경이 더 효율적일 것 같네요.

추가로 멀티 프로세스 환경에서 프로세스 간 정보를 공유하기 위해서 IPC (Inter-Process Communication) 를 사용해야 합니다. 서로 다른 프로세스 간의 메모리가 격리되어있기 때문에 직접 접근이 불가능하고, 데이터 공유를 위한 복사나 전송 작업이 수행됩니다. 멀티 스레드 환경을 사용한다면 서로 다른 스레드이더라도 데이터 공유가 가능하기 때문에 복잡한 통신을 사용할 필요가 없습니다.

### 병렬성

CPU에는 코어(Core) 라는 개념이 있습니다. 코어는 명령어를 처리하는 역할을 맡고 있어요. 이전까지의 설명은 모두 CPU가 하나의 코어를 가지고 있을 때를 기준으로 설명하였습니다.

하나의 코어는 동시에 하나의 일만 할 수 있기 때문에, 사용자에게 마치 실제로 동시에 작업하는 것처럼 보이기 위한 방법으로 멀티 프로세스, 멀티 스레드를 언급하였습니다.

즉 멀티 스레드 환경에서 스레드가 번갈아 작업을 할 때 CPU 코어가 한 개라면 아래 사진처럼 스레드 간의 작업이 절대 겹치지 않습니다.

![image](https://github.com/user-attachments/assets/4c1fbafa-ae8b-4c72-a581-ee53c1ad5d2a)


동시성과 다르게 병렬성 (Parallelism) 은 실제로 여러 작업을 동시에 실행하여 효율적으로 작업을 처리하는 것을 말합니다.
하나의 CPU 코어는 하나의 일만 할 수 있으니, 여러 작업을 실제로 동시에 처리하기 위해서는 여러 CPU 코어가 필요하겠죠.
그래서 나타난 개념이 멀티 코어입니다. 병렬성은 여러 개의 CPU나 코어를 활용해 작업 처리 속도를 향상시켜요.


여러 CPU 코에서 여러 개의 스레드를 사용해 동시 작업을 수행한다면 이러한 흐름도 가능할 것 같아요.

![image](https://github.com/user-attachments/assets/3b35574a-dd83-44df-a1c0-a5f2cd0ba442)

동시에 여러 스레드가 작업을 수행하여 스레드 간 작업이 겹치는 일이 발생할 수 있어요. 그래서 하나의 자원을 두고 두 스레드가 경쟁하는 일이 생길 수 있습니다.

### JVM에서 스레드가 생성되는 방식

자바 애플리케이션은 멀티 스레드 환경을 지원하고, 새로운 스레드가 생성될 때 기본 운영 체제의 스레딩 기능을 활용합니다.
운영 체제 자체의 여러 CPU 코어로부터 CPU 스케줄링 기법을 사용해 스레드를 생성합니다. 그래서 JVM 내에서 생성되는 스레드 역시 멀티 코어로 동작한다고 할 수 있어요.


## 문제 원인 분석하기

서론에서 설명드렸던 문제도 이와 관련이 있습니다.

우선 싱글 코어 환경을 가정하고 문제 상황을 설명하겠습니다.

Thread1에 제일 먼저 요청이 들어오고, 동시에 다른 요청이 들어와 Thread2가 생성된 상황 이라고 합시다.
각 요청은 같은 참여자는 동시에 모임에 참여할 수 없다 라는 요구사항을 충족시키기 위해 검증 로직을 거칩니다. 그리고 이상이 없다면 DB에 저장이 될 것이에요.

의도했던 상황이라면 아래와 같이 검증 로직이 정상적으로 동작하고, 이미 참여한 모임이므로 DB에 새롭게 저장하지 않을 것입니다.

![image](https://github.com/user-attachments/assets/a5eae185-2e69-46cb-a5f6-65f126e20484)

하지만 멀티 스레드 환경에서 스레드가 동시에 동작한다면 아래와 같은 시나리오를 가정해볼 수 있습니다.

![image](https://github.com/user-attachments/assets/d4cbf440-97a9-4321-914e-5515439b4ca0)

동시에 여러 스레드가 동작하고 있기 때문에 두 번째 요청에 대한 검증 시 첫 번째 요청에 대한 변경이 반영되지 않았어요.
그래서 의도된 상황이 아님에도 두 번째 요청 역시 데이터베이스에 저장될 수 있었습니다.

멀티 코어 환경에서도 마찬가지입니다. 심지어 스레드가 동시에 실제로 실행될 수 있기 때문에 동시 요청에 의해 에러 상황이 생기기 더욱 쉬워요.


이러한 문제를 경쟁 조건 (Race Condition)이라고 합니다. 여러 스레드가 공유된 자원에 접근하기 때문에 어떤 순서로 접근했는지에 따라 다른 결과가 나오는 상황을 의미합니다.



# 해결 방법

스레드 간 동시성에 의해 생길 수 있는 이러한 문제를 해결하기 위한 방법은 무엇일까요?

가장 간단한 방법으로는 한 번에 하나의 스레드만 공유하고 있는 데이터에 접근하는 것입니다.  
Java에서는 synchronized 를 제공하여 메서드 단위의 동기화를 지원하고 있습니다.


```java
	public synchronized void chamyoMoim(Long darakbangId, Long moimId, DarakbangMember darakbangMember) {
		Moim moim = moimFinder.read(moimId, darakbangId);
		chamyoWriter.saveAsMoimee(moim, darakbangMember);
		moimWriter.updateMoimStatusIfFull(moim);

		notificationService.notifyToMembers(NotificationType.NEW_MOIMEE_JOINED, darakbangId, moim, darakbangMember);
	}
```

synchronized 메서드를 사용하는 모든 스레드는 Lock을 가지고 있어야 합니다. 해당 메서드에 대한 Lock을 가진 상태로 스레드가 작업을 처리하는 동안에 다른 스레드는 해당 메서드에 접근할 수 없습니다.

![image](https://github.com/user-attachments/assets/5d01cb72-553f-4eca-9188-31146e277137)

즉 다음과 같이 한 스레드에 대한 모든 작업이 끝났을 때 다른 요청을 처리하는 방식입니다.

다른 방법으로는 상호 배제 (Mutual exclusion) 라는 방법이 있습니다. 공유 자원에 대한 접근을 막아서 동기화를 지원하는 방식입니다. 한 스레드가 자원을 점유하고 있는 동안 다른 스레드가 자원을 요청했을 때, 바로 접근하지 않고 앞선 스레드의 자원 점유가 끝날 때까지 대기하는 방식입니다.

![image](https://github.com/user-attachments/assets/d3f1a518-d8e7-4b45-908a-8416a47513d6)

제일 먼저 요청을 보내 할당된 스레드가 모임에 대한 자원을 점유하고 있습니다.


![image](https://github.com/user-attachments/assets/2b0f611b-6a83-4e8a-8674-7f8262451deb)

동시에 요청을 보내 할당된 두번째 스레드 역시 모임을 점유하려 하지만 공유 자원에 대한 동시 접근이 불가능하기 때문에 대기하게 됩니다.

![image](https://github.com/user-attachments/assets/81e086ea-560d-4dcf-9c04-9deaefe3ec79)

이후 Thread1에 대한 작업이 모두 끝나고 공유 자원에 대한 점유가 끝났을 때 비로소 Thread2가 자원을 사용할 수 있습니다.

## 프로젝트에 적용해 본 방식

저의 경우 처음에는 상호 배제 방식을 이용해 동시성으로 인한 문제를 해소하고자 하였습니다. 모임 데이터에 대한 비관적 락 (Pessimistic Lock) 을 걸어 멀티 스레드 환경에서 여러 트랜잭션이 생성되었을 때 상호 배제를 사용하였습니다.

그래서 여러 요청이 들어오더라도 데이터베이스 단에서 레코드 단위로 락이 걸려있기 때문에 Race Condition을 해결할 수 있었습니다.

제 방식이 정답이라고 할 수 없지만, 멀티 스레드 환경에서 공유 데이터의 동시 접근을 막아 해결한 상호 배제 방식 중 하나입니다.

# 마무리하며

지금까지 프로젝트에서 발생한 문제를 스레드 관점에서 알아보고, 해결 방법을 알아보았습니다.

멀티 스레드 환경의 탄생 의의가 효율성에 있지만 설명한 것과 같이 프로그래밍 의도와 다른 결과가 나올 수 있다는 단점이 있었습니다. 두 가지 측면에 대해 트레이드 오프를 통해 적절한 해결 방식을 찾고, 프로젝트에 적용하는 것이 중요하다는 결론입니다.


참고

[경쟁 조건](https://www.javatpoint.com/race-condition-in-java)

자바의 정석
